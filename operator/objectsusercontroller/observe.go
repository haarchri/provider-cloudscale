package objectsusercontroller

import (
	"context"
	"fmt"

	pipeline "github.com/ccremer/go-command-pipeline"
	cloudscalesdk "github.com/cloudscale-ch/cloudscale-go-sdk/v2"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	cloudscalev1 "github.com/vshn/provider-cloudscale/apis/cloudscale/v1"
	"github.com/vshn/provider-cloudscale/operator/steps"
	controllerruntime "sigs.k8s.io/controller-runtime"
)

// Observe implements managed.ExternalClient.
func (p *ObjectsUserPipeline) Observe(ctx context.Context, mg resource.Managed) (managed.ExternalObservation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.V(1).Info("Observing resource")

	user := fromManaged(mg)
	if user.Status.AtProvider.UserID == "" {
		if userId, exists := user.Annotations[UserIDAnnotationKey]; exists {
			// get the user ID generated by Create() via annotation, since in Create() we're not allowed to update the status.
			user.Status.AtProvider.UserID = userId
			delete(user.Annotations, UserIDAnnotationKey) // might not work
		} else {
			// New resource, create user first
			return managed.ExternalObservation{}, nil
		}
	}

	err := p.getObjectsUserFn(user)(ctx)
	if err != nil {
		return managed.ExternalObservation{}, resource.Ignore(isNotFound, err)
	}

	csUser := p.csUser
	user.Status.AtProvider.Tags = fromTagMap(csUser.Tags)
	user.Status.AtProvider.DisplayName = csUser.DisplayName

	if tagsNeedUpdate(user.Spec.ForProvider.Tags, csUser.Tags) || user.GetDisplayName() != csUser.DisplayName {
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false, ConnectionDetails: toConnectionDetails(csUser)}, nil
	}

	result := pipeline.NewPipeline().WithBeforeHooks(steps.DebugLogger(ctx)).WithSteps(
		pipeline.If(hasSecretRef(user),
			pipeline.NewPipeline().WithNestedSteps("observe credentials secret",
				pipeline.NewStepFromFunc("fetch credentials secret", p.fetchCredentialsSecretFn(user)),
				pipeline.NewStepFromFunc("compare credentials", p.checkCredentials),
			).WithErrorHandler(p.observeCredentialsHandler),
		),
	).RunWithContext(ctx)
	if result.IsFailed() {
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false, ConnectionDetails: toConnectionDetails(csUser)}, nil
	}

	user.SetConditions(xpv1.Available())
	return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: true, ConnectionDetails: toConnectionDetails(csUser)}, nil
}

// getObjectsUserFn fetches an existing objects user from the project associated with the API token.
func (p *ObjectsUserPipeline) getObjectsUserFn(user *cloudscalev1.ObjectsUser) func(ctx context.Context) error {
	return func(ctx context.Context) error {
		csClient := p.csClient
		log := controllerruntime.LoggerFrom(ctx)

		csUser, err := csClient.ObjectsUsers.Get(ctx, user.Status.AtProvider.UserID)
		if err != nil {
			return err
		}
		p.csUser = csUser
		log.V(1).Info("Fetched objects user in cloudscale", "userID", csUser.ID, "displayName", csUser.DisplayName, "tags", csUser.Tags)
		return nil
	}
}

func (p *ObjectsUserPipeline) observeCredentialsHandler(ctx context.Context, err error) error {
	log := controllerruntime.LoggerFrom(ctx)
	log.V(1).Error(err, "Credentials Secret needs reconciling")
	return nil
}

func (p *ObjectsUserPipeline) checkCredentials(_ context.Context) error {
	data := p.credentialsSecret.Data

	if len(data) == 0 {
		return fmt.Errorf("secret %q does not have any data", fmt.Sprintf("%s/%s", p.credentialsSecret.Namespace, p.credentialsSecret.Name))
	}

	for key, desired := range toConnectionDetails(p.csUser) {
		if observed, exists := data[key]; !exists || string(observed) != string(desired) {
			return fmt.Errorf("secret %q is missing on of the following keys or content: %s", fmt.Sprintf("%s/%s", p.credentialsSecret.Namespace, p.credentialsSecret.Name), key)
		}
	}
	return nil
}

func isNotFound(err error) bool {
	var errResp *cloudscalesdk.ErrorResponse
	if errors.As(err, &errResp) {
		return errResp.StatusCode == 404
	}
	return false
}
